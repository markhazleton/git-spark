# Git Spark Constitution (DRAFT)

> ⚠️ **DRAFT**: Generated by /speckit.discover-constitution on 2026-02-20  
> Review carefully before finalizing. Run /speckit.constitution to formalize.

## Discovery Context

- **Source**: Analyzed 15 source files, 15 test files in git-spark repository
- **Stack**: TypeScript + Node.js 20+ + Jest + ESM + GitHub Actions
- **Patterns Found**: 13 high-confidence (>80%), 3 medium-confidence (50-80%)
- **Coverage**: Code Quality, Testing, Security, CI/CD, Documentation, Architecture, Analytics

---

## Core Principles

### I. Type Safety (MANDATORY)

All TypeScript code **MUST** compile with strict mode and enhanced type checking enabled.

**Rules (MUST):**
- `strict: true` in tsconfig.json
- `noImplicitAny: true` - no implicit any types
- `noUnusedLocals: true` - no unused variables
- `noUnusedParameters: true` - no unused parameters
- `exactOptionalPropertyTypes: true` - strict optional handling
- Zero TypeScript compilation errors

**Evidence:**
- tsconfig.json has all strict flags enabled
- 100% of source files compile under strict mode
- CI pipeline enforces compilation success

**Rationale:** Type safety catches errors at compile time, improves refactoring safety, and provides better IDE support.

---

### II. Testing Standards (MANDATORY)

All code changes **MUST** include tests with enforced coverage thresholds.

**Rules (MUST):**
- All new features must include Jest tests
- Tests located in separate `test/` directory
- Test files use `*.test.ts` naming convention
- Coverage thresholds enforced:
  - Branches: ≥75%
  - Functions: ≥87%
  - Lines: ≥86%
  - Statements: ≥85%
- Pre-commit hook runs tests (blocks failing tests)
- Test timeout: 30 seconds maximum
- Test environment: Node.js with ts-jest

**Evidence:**
- 100% of features have corresponding test files
- Jest configuration in package.json enforces thresholds
- Husky pre-commit hook: `npm test`
- 15 test files covering all core modules

**Rationale:** Comprehensive testing prevents regressions, ensures reliability, and enables confident refactoring.

---

### III. Security - Command Injection Prevention (MANDATORY)

All external command execution **MUST** use parameterized execution to prevent injection attacks.

**Rules (MUST):**
- Use `spawn(command, args)` with argument arrays, never shell string concatenation
- Validate and sanitize all user input before execution
- Implement buffer limits to prevent DoS (200MB default)
- Implement timeouts for long-running operations (60s default)
- No use of `exec()` or `shell: true` with user-provided data

**Rules (SHOULD):**
- Log all command executions for audit trail
- Include command validation in unit tests

**Evidence:**
- src/utils/git.ts: `spawn('git', args, { cwd: options.cwd })`
- src/utils/input-validation.ts: `validateGitOptions()` sanitizes all inputs
- Zero instances of string concatenation in shell commands
- Buffer and timeout protection in GitExecutor class

**Rationale:** Command injection is a critical security vulnerability. Parameterized execution eliminates this attack vector.

---

### IV. CI/CD Pipeline (MANDATORY)

All code **MUST** pass the complete CI/CD pipeline before merge to main branch.

**Rules (MUST):**
- Lint must pass: `npm run lint`
- Tests must pass: `npm run test`
- Build must succeed: `npm run build`
- Security audit must pass: `npm audit --audit-level=moderate`
- Multi-OS testing: Ubuntu, Windows, macOS
- Multi-version Node.js: 20.x, 22.x
- No bypassing CI checks without explicit approval

**Rules (MUST - Git Hooks):**
- Pre-commit: lint + test (enforced via Husky)
- Pre-push: build (enforced via Husky)

**Evidence:**
- .github/workflows/ci.yml: comprehensive CI pipeline
- .github/workflows/security.yml: weekly security scans
- .husky/pre-commit: blocks commits if lint or tests fail
- .husky/pre-push: blocks push if build fails

**Rationale:** Automated quality gates prevent broken code from reaching production and maintain consistent code quality.

---

### V. Documentation Standards (MANDATORY)

All exported APIs **MUST** have JSDoc documentation with examples and parameter descriptions.

**Rules (MUST):**
- All exported classes, interfaces, functions must have JSDoc
- Include `@param` for all parameters with descriptions
- Include `@returns` for all return values
- Include `@example` for public APIs
- Document error conditions with `@throws`

**Rules (SHOULD):**
- Complex internal logic should have inline comments
- Use meaningful variable/function names (self-documenting code)

**Evidence:**
- src/index.ts: Full JSDoc on GitSpark class with usage examples
- src/core/analyzer.ts: Comprehensive class and method documentation
- src/types/index.ts: All interfaces documented with field descriptions
- ~80% of exports have complete JSDoc

**Rationale:** Documentation enables library consumers to use APIs correctly and reduces support burden.

---

### VI. Analytical Integrity (MANDATORY - Git Spark Specific)

All analytics metrics **MUST** be derivable from Git commit data with documented limitations.

**Rules (MUST):**
- Metrics based only on Git commit metadata (author, date, files, message)
- Never infer work hours, code quality, developer performance, or test coverage
- Use honest naming: "commitTimePattern" not "workingHours"
- Include `limitations` object in metric types explaining:
  - `dataSource`: Where data comes from
  - `knownLimitations[]`: What the metric cannot measure
  - `recommendedApproach`: How to get complete data
- No subjective "recommendations" in reports

**Rules (MUST NOT):**
- Do not claim to measure actual work hours from commit timestamps
- Do not claim to measure code quality from commit metadata
- Do not claim to measure code review participation without review platform data
- Do not rank developers or teams subjectively

**Evidence:**
- Removed subjective recommendations (test/analyzer.test.ts)
- Types include MetricLimitations interfaces
- README and SECURITY.md emphasize "Git-only data"
- File risk scoring uses objective weighted factors only

**Rationale:** Git Spark prioritizes transparency over completeness. Better to clearly explain what we CAN'T measure than provide misleading insights.

---

### VII. Logging Strategy (MANDATORY)

Logging **MUST** be separated by concern: CLI for user interaction, structured logger for internal operations.

**Rules (MUST):**
- CLI layer (`src/cli/**`): Use `console.log/error/warn` with Chalk for user-facing output
- Core/Utils layers (`src/core/**`, `src/utils/**`): Use structured logger with debug levels
- Never use console.* in core/utils layers
- Logger must support: debug, info, warn, error levels
- Logger must include context (module name, relevant data)

**Rules (SHOULD):**
- Use progress callbacks for long-running operations
- Include timing information for performance-critical operations

**Evidence:**
- src/cli/commands.ts: Consistent console.* usage with Chalk colors
- src/utils/logger.ts: createLogger() factory with debug levels
- src/core/analyzer.ts: Uses structured logger, never console
- Clear separation maintained across 100% of codebase

**Rationale:** Separation of concerns enables debugging without cluttering user output and allows different logging strategies per environment.

---

### VIII. HTML Security (MANDATORY)

All HTML report generation **MUST** follow security-first principles.

**Rules (MUST):**
- Implement Content Security Policy with SHA-256 hashed inline scripts
- No `unsafe-inline` or `unsafe-eval` in CSP
- HTML-escape all user-generated content before template insertion
- Native SVG charts only (no external charting libraries)
- Self-contained reports (no external API calls, air-gap capable)
- Integrity checks on external CDN resources (Bootstrap CSS)
- Support email redaction (`--redact-emails` flag)

**Rules (SHOULD):**
- Keep external dependencies minimal
- Prefer native browser features over libraries

**Evidence:**
- src/output/html.ts: SHA-256 CSP implementation
- All user content (author names, commit messages) escaped
- Bootstrap CSS loaded with integrity="sha384-..." hash
- Zero external JavaScript dependencies
- Self-contained: all data embedded in HTML

**Rationale:** Security-first HTML ensures reports can be safely shared publicly and reviewed in air-gapped environments.

---

### IX. Dependency Management (MANDATORY)

Dependencies **MUST** be regularly audited and kept up-to-date.

**Rules (MUST):**
- Weekly security audits via GitHub Actions (scheduled)
- npm audit must pass at `moderate` severity level
- CodeQL analysis on all pushes
- Snyk vulnerability scanning
- No known vulnerabilities at moderate+ severity allowed in production
- Automated dependency update PRs via GitHub Actions

**Rules (SHOULD):**
- Review dependency updates within 7 days
- Test thoroughly after major version updates
- Document breaking changes in CHANGELOG.md

**Evidence:**
- .github/workflows/security.yml: Weekly scheduled scans
- .github/workflows/ci.yml: Security audit on every PR
- Snyk integration configured
- Automated PR creation for dependency updates

**Rationale:** Supply chain security is critical. Regular audits prevent vulnerabilities from reaching production.

---

### X. Architecture - Layered Design (MANDATORY)

Code **MUST** follow the established three-layer architecture.

**Rules (MUST):**
- **CLI Layer** (`src/cli/**`): Argument parsing, validation, user interaction only
- **Core Layer** (`src/core/**`): Business logic, analysis, data processing
- **Output Layer** (`src/output/**`): Format-specific serialization
- **Utils Layer** (`src/utils/**`): Shared utilities, no business logic
- No circular dependencies between layers
- Data flows: CLI → Core → Output (never backwards)

**Rules (SHOULD):**
- Extract reusable logic to utils
- Keep layers focused on single responsibility
- Use dependency injection for testability

**Evidence:**
- Clear directory structure: cli/, core/, output/, utils/
- src/cli/commands.ts orchestrates but doesn't implement analysis
- src/core/analyzer.ts contains business logic, no CLI concerns
- src/output/* only handles serialization, no analysis
- Zero circular dependencies detected

**Rationale:** Layered architecture enables testing, maintainability, and clear separation of concerns.

---

### XI. Module System (MANDATORY)

All code **MUST** use ECMAScript Modules (ESM) with explicit file extensions.

**Rules (MUST):**
- `"type": "module"` in package.json
- All imports must include `.js` extension (even for `.ts` files)
- Use `import/export` syntax, no CommonJS `require()`
- Module resolution: `bundler` mode in tsconfig.json
- Target: ES2020 or later

**Rules (MUST NOT):**
- No `require()` or `module.exports` in new code
- No `.cjs` files except configuration (ESLint, etc.)

**Evidence:**
- package.json: `"type": "module"`
- tsconfig.json: `"module": "ES2020"`, `"moduleResolution": "bundler"`
- 100% of imports use `.js` extensions: `import { foo } from './bar.js'`
- Jest configured with ESM support

**Rationale:** ESM is the standard module system, provides better tree-shaking, and aligns with modern JavaScript ecosystem.

---

### XII. Code Quality - Linting & Formatting (MANDATORY)

All code **MUST** pass ESLint and Prettier checks.

**Rules (MUST):**
- ESLint: No errors, warnings should be minimized
- Prettier: All files formatted with project config
- Pre-commit hook enforces linting
- CI pipeline blocks merge if lint fails
- Configuration files:
  - `eslint.config.cjs`: ESLint rules
  - `.prettierrc`: Prettier formatting

**Prettier Config:**
- Semi-colons: required
- Single quotes: yes
- Print width: 100 characters
- Tab width: 2 spaces
- Trailing commas: ES5

**Evidence:**
- eslint.config.cjs: TypeScript-aware rules configured
- .prettierrc: Consistent formatting rules
- package.json: `lint` and `format` scripts
- .husky/pre-commit: Runs `npm run lint`
- CI blocks merge if lint fails

**Rationale:** Consistent code style reduces review friction and prevents style debates. Automated enforcement ensures compliance.

---

### XIII. Runtime Requirements (MANDATORY)

Git Spark **MUST** support specified Node.js versions and environments.

**Rules (MUST):**
- Node.js: ≥20.19.0 (LTS)
- npm: ≥10.0.0
- Multi-OS support: Linux, macOS, Windows
- CI tests on all supported platforms
- Engines field enforced in package.json

**Rules (SHOULD):**
- Support latest LTS and current Node.js versions
- Test on multiple Node.js versions in CI (20.x, 22.x)

**Evidence:**
- package.json: `"engines": { "node": ">=20.19.0", "npm": ">=10.0.0" }`
- CI matrix: Ubuntu, Windows, macOS × Node 20.x, 22.x
- All 6 platform combinations tested on every PR

**Rationale:** Clear runtime requirements prevent compatibility issues and ensure consistent behavior across environments.

---

## Additional Constraints

### Code Organization

**MUST:**
- One class per file (exceptions: small helper classes)
- Meaningful file names matching exported entity
- Group related files in appropriate directories
- Keep files under 500 lines (exceptions require justification)

**SHOULD:**
- Extract large functions into smaller ones (≤50 lines guideline)
- Use descriptive variable/function names over comments
- Prefer composition over inheritance

### Error Handling

**MUST:**
- Use custom error classes (GitError, ValidationError)
- Include context in error messages (command, parameters)
- Clean up resources on error (timeouts, child processes)
- Handle SIGINT gracefully (Ctrl+C)

**SHOULD:**
- Validate inputs early (fail fast)
- Provide actionable error messages
- Log errors with sufficient context for debugging

### Performance

**MUST:**
- Implement timeouts for external operations (Git commands)
- Use buffer limits to prevent memory exhaustion
- Handle large repositories (100k+ commits)

**SHOULD:**
- Use streaming for large data processing
- Implement progress callbacks for long operations
- Profile performance-critical code paths

---

## Governance

### Constitution Authority

- This constitution supersedes informal practices and preferences
- All PRs must be reviewed for constitutional compliance
- Violations must be addressed before merge

### Amendment Process

**MUST:**
- Amendments require documented rationale
- Team discussion and consensus for major changes
- Update constitution version and "Last Amended" date
- Migration plan for changes affecting existing code

**SHOULD:**
- Review constitution quarterly for relevance
- Gather team feedback on pain points
- Keep constitution pragmatic, not bureaucratic

### Review Process

**All PRs must verify:**
1. TypeScript strict mode compliance
2. Test coverage thresholds met
3. Security patterns followed (parameterized execution)
4. Documentation complete for exports
5. CI pipeline passes (lint, test, build, security)
6. Analytical integrity maintained (Git-only metrics)
7. Architecture layers respected
8. Code quality checks pass

### Enforcement

**Violation Severity:**
- **CRITICAL**: Blocks merge immediately (security, type safety, testing)
- **HIGH**: Requires fix before merge (documentation, CI)
- **MEDIUM**: Should fix before merge, can defer with justification
- **LOW**: Nice-to-have, address in future PR

---

**Version**: 0.1.0-draft  
**Generated**: 2026-02-20  
**Ratified**: [Pending Review]  
**Last Amended**: [Pending Review]

---

## Notes for Review

### Strengths Discovered
1. **Strong Security Culture**: Parameterized commands, input validation, CSP, security audits
2. **Comprehensive Testing**: High coverage thresholds, automated enforcement, git hooks
3. **Analytical Honesty**: Unique principle of Git-only metrics with documented limitations
4. **Modern Stack**: ESM, TypeScript strict, Node 20+, GitHub Actions
5. **Layered Architecture**: Clear separation of concerns (CLI → Core → Output)

### Areas Needing Team Discussion
1. Should we add explicit API design principles (REST/GraphQL if applicable)?
2. Performance benchmarking requirements (currently informal)?
3. Accessibility requirements for HTML reports (WCAG compliance)?
4. Contribution guidelines for external contributors?

### Recommended Constitution Refinements
1. Add specific examples to each principle (reference actual files)
2. Create enforcement checklist for PR reviews
3. Add "When in Doubt" section for gray areas
4. Consider creating separate "Implementation Guidance" document for day-to-day development
